<!-- Created by Michael Simms -->
<!-- Copyright (c) 2025 Michael Simms -->

<!DOCTYPE html>
<html lang="en-US">

<head>

<title>Dashboard</title>

<link rel="stylesheet" type="text/css" href="${root_url}/css/normalize.css">
<link rel="stylesheet" type="text/css" href="${root_url}/css/site.css">
<link rel="stylesheet" type="text/css" href="${root_url}/css/gauges.css">
<link rel="stylesheet" type="text/css" href="${root_url}/css/graphs.css">
<link rel="shortcut icon" href="${root_url}/media/favicon.ico">

<meta charset="UTF-8">

</head>

<body>

<!-- Gauges Start -->
<div class="block">
    <div id="gauges" class="block gauge-container">
        <div>
            <h3>Indoor CO<sup>2</sup> (PPM)</h3>
            <canvas id="indoor-co2-gauge"></canvas>
        </div>
        <div>
            <h3>Indoor Temperature (&deg;C)</h3>
            <canvas id="indoor-temp-gauge"></canvas>
        </div>
        <div>
            <div id="keg-level"></div>
        </div>
    </div>
</div>
<!-- Gauges End -->

<!-- Graphs Start -->
<div id="charts" class="charts">
</div>
<!-- Graphs End -->

<!-- Notifications Start -->
<div class="block">
    <div>
        <button id="enable_notifications">Enable Notifications</button>
    </div>
</div>
<!-- Notifications Start -->

<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/4.13.0/d3.min.js" integrity="sha512-RJJ1NNC88QhN7dwpCY8rm/6OxI+YdQP48DrLGe/eSAd+n+s1PXwQkkpzzAgoJe4cZFW2GALQoxox61gSY2yQfg==" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/gaugeJS/dist/gauge.min.js"></script>
<script src="${root_url}/js/js-fluid-meter.js"></script>
<script src="${root_url}/js/common.js"></script>
<script src="${root_url}/js/cookies.js"></script>
<script src="${root_url}/js/graphs.js"></script>
<script>

    // Initialize the graph start time to this time, yesterday.
    var g_readings_start_time = new Date(new Date().getTime() - (24 * 60 * 60 * 1000));

    // Gauges
    var g_co2_gauge = null;

    // Graphs
    var g_co2_graph = null;
    var g_temp_graph = null;
    var g_humidity_graph = null;
    var g_keg_level = null;
    var g_voc_graph = null;
    var g_voc_index_graph = null;
    var g_ac_outlet_temp_graph = null;
    var g_patio_temp_graph = null;
    var g_patio_humidity_graph = null;
    var g_patio_wind_speed_graph = null;
    var g_patio_moisture1_graph = null;
    var g_patio_moisture2_graph = null;
    var g_website_status_graphs = {};

    /// @function draw_co2_gauge
    /// Creates a co2 gauge.
    function draw_co2_gauge(element_id) {
        // Gauge options
        var opts = {
            angle: 0.15, // Span of the gauge arc (0 = full circle, 0.15 ~ half circle)
            lineWidth: 0.25, // Relative thickness
            radiusScale: 1.0,

            pointer: {
                length: 0.7, // Relative to gauge radius
                strokeWidth: 0.04,
                color: "#aaaaaa"
            },

            // Background zones for the arc
            staticZones: [
                { strokeStyle: "#30B32D", min: 0,    max: 800 },  // Green
                { strokeStyle: "#FFDD00", min: 800,  max: 1500 }, // Yellow
                { strokeStyle: "#F03E3E", min: 1500, max: 2000 }  // Red
            ],

            // Value labels around the arc
            staticLabels: {
                font: "12px sans-serif",
                labels: [0, 400, 800, 1200, 1600, 2000],
                color: "#aaaaaa",
                fractionDigits: 0
            },

            // Style of the remaining (unused) arc
            strokeColor: "#E0E0E0",
            limitMax: true,
            limitMin: true,
            highDpiSupport: true
        };

        var target = document.getElementById(element_id);
        var gauge = new Gauge(target).setOptions(opts);

        // Configure the range.
        gauge.maxValue = 2000;
        gauge.setMinValue(0);
        gauge.animationSpeed = 32;

        return gauge;
    }

    /// @function draw_temperature_gauge
    /// Creates a draw_temperature_gauge gauge.
    function draw_temperature_gauge(element_id) {
        // Gauge options
        var opts = {
            angle: 0.15, // Span of the gauge arc (0 = full circle, 0.15 ~ half circle)
            lineWidth: 0.25, // Relative thickness
            radiusScale: 1.0,

            pointer: {
                length: 0.7, // Relative to gauge radius
                strokeWidth: 0.04,
                color: "#aaaaaa"
            },

            // Background zones for the arc
            staticZones: [
                { strokeStyle: "#2b2dfb", min: -10, max: 10 }, // Blue
                { strokeStyle: "#30B32D", min: 10,  max: 25 }, // Green
                { strokeStyle: "#FFDD00", min: 25,  max: 30 }, // Yellow
                { strokeStyle: "#F03E3E", min: 30,  max: 50 }  // Red
            ],

            // Value labels around the arc
            staticLabels: {
                font: "12px sans-serif",
                labels: [-10, 0,10, 20, 30, 40, 50],
                color: "#aaaaaa",
                fractionDigits: 0
            },

            // Style of the remaining (unused) arc
            strokeColor: "#E0E0E0",
            limitMax: true,
            limitMin: true,
            highDpiSupport: true
        };

        var target = document.getElementById(element_id);
        var gauge = new Gauge(target).setOptions(opts);

        // Configure the range.
        gauge.maxValue = 50;
        gauge.setMinValue(-10);
        gauge.animationSpeed = 32;

        return gauge;
    }

    /// @function draw_fluid_graph
    function draw_fluid_graph(element_id) {
        var meter = new FluidMeter();
        meter.init({
            targetContainer: document.getElementById(element_id),
            fillPercentage: 45,
            options: {
                fontSize: "24px",
                drawPercentageSign: true,
                drawBubbles: true,
                size: 150,
                borderWidth: 1,
                backgroundColor: "#e2e2e2",
                foregroundColor: "#fafafa",
                foregroundFluidLayer: {
                    fillStyle: "#16E1FF",
                    angularSpeed: 30,
                    maxAmplitude: 5,
                    frequency: 30,
                    horizontalSpeed: -20
                },
                backgroundFluidLayer: {
                    fillStyle: "#4F8FC6",
                    angularSpeed: 100,
                    maxAmplitude: 3,
                    frequency: 22,
                    horizontalSpeed: 20
                }
            }
        });
        return meter;
    }

    /// @function fetch_more_graph_data
    function fetch_more_graph_data(settings, min_x, max_x) {
        if (settings.element_id == "co2_chart" ||
            settings.element_id == "temp_chart" ||
            settings.element_id == "humidity_chart" ||
            settings.element_id == "voc_chart" ||
            settings.element_id == "voc_index_chart") {
            get_indoor_air_quality_readings(min_x / 1000.0);
        }
        else if (
            settings.element_id == "temperature" ||
            settings.element_id == "humidity" ||
            settings.element_id == "wind_speed_ms" ||
            settings.element_id == "moisture_sensor_1" ||
            settings.element_id == "moisture_sensor_2") {
            get_patio_monitor_readings(min_x / 1000.0);
        }
        else if (
            settings.element_id == "ac_outlet_temp") {
            get_ac_readings(min_x / 1000.0);
        }
    }

    /// @function create_graph_settings
    function create_graph_settings(element_id, label, unit_label, color, height) {
        var settings = new GraphSettings();
        settings.element_id = element_id;
        settings.label = label;
        settings.unit_label = unit_label;
        settings.color = color;
        settings.height = height;
        settings.fill = false;
        settings.more_data_func = fetch_more_graph_data;
        return settings;
    }

    /// @function check_for_notifications
    function check_for_notifications(values, key) {
        if (values.length == 0) {
            return;
        }

        // If we're not logged in then we won't get the alarm limits.
        session_cookie = get_session_cookie();
        if (session_cookie == null) {
            return;
        }

        let api_url = "${root_url}/api/1.0/limits?key=" + key + "&session_cookie=" + session_cookie;

        send_get_request_async(api_url, function (response_code, response_text) {
            if (response_code == 200) {
                const limits = JSON.parse(response_text);
                let most_recent = values.at(-1);

                if ('upper_limit' in limits) {
                    let limit = limits['upper_limit'];
                    if (most_recent.y > limit) {
                        let msg = key + " is over the limit of " + limit;
                        maybe_notify(msg);
                    }
                }
                if ('lower_limit' in limits) {
                    let limit = limits['lower_limit'];
                    if (most_recent.y < limit) {
                        let msg = key + " is under the limit of " + limit;
                        maybe_notify(msg);
                    }
                }
            }
        });
    }

    /// @function get_indoor_air_quality_readings
    function get_indoor_air_quality_readings(start_ts) {
        let api_url = "${root_url}/api/1.0/indoor_air?start_ts=" + start_ts

        send_get_request_async(api_url, function (response_code, response_text) {
            if (response_code == 200) {
                const CHART_HEIGHT = 250;
                const records = JSON.parse(response_text);

                var co2_readings = [];
                var temp_readings = [];
                var humidity_readings = [];
                var voc_readings = [];
                var voc_index_readings = [];

                for (let record of records) {
                    let ts = record['ts'];
                    if (record[CO2_KEY] != null)
                        co2_readings.push( { x: ts, y: record[CO2_KEY] });
                    if (record[TEMP_KEY] != null)
                        temp_readings.push( { x: ts, y: record[TEMP_KEY] });
                    if (record['humidity'] != null)
                        humidity_readings.push( { x: ts, y: record['humidity'] });
                    if (record['voc'] != null)
                        voc_readings.push( { x: ts, y: record['voc'] });
                    if (record['voc_index'] != null)
                        voc_index_readings.push( { x: ts, y: record['voc_index'] });
                }

                if (co2_readings.length > 0) {
                    if (g_co2_graph == null) {
                        g_co2_graph = create_graph_settings("co2_chart", "Indoor CO2", "PPM", "yellow", CHART_HEIGHT);
                        draw_graph2(co2_readings, g_co2_graph);
                    }
                    else {
                        g_co2_graph.update_func(co2_readings);
                    }
                    g_co2_gauge.set(co2_readings.at(-1).y);
                    check_for_notifications(co2_readings, CO2_KEY);
                }
                if (temp_readings.length > 0) {
                    if (g_temp_graph == null) {
                        g_temp_graph = create_graph_settings("temp_chart", "Indoor Temperature", "C", "red", CHART_HEIGHT);
                        draw_graph2(temp_readings, g_temp_graph);
                    }
                    else {
                        g_temp_graph.update_func(temp_readings);
                    }
                    g_indoor_temp_gauge.set(temp_readings.at(-1).y);
                    check_for_notifications(temp_readings, TEMP_KEY);
                }
                if (humidity_readings.length > 0) {
                    if (g_humidity_graph == null) {
                        g_humidity_graph = create_graph_settings("humidity_chart", "Indoor Humidity", "%", "blue", CHART_HEIGHT);
                        draw_graph2(humidity_readings, g_humidity_graph);
                    }
                    else {
                        g_humidity_graph.update_func(humidity_readings);
                    }
                }
                if (voc_readings.length > 0) {
                    if (g_voc_graph == null) {
                        g_voc_graph = create_graph_settings("voc_chart", "VOC", "", "green", CHART_HEIGHT);
                        draw_graph2(voc_readings, g_voc_graph);
                    }
                    else {
                        g_voc_graph.update_func(voc_readings);
                    }
                }
                if (voc_index_readings.length > 0) {
                    if (g_voc_index_graph == null) {
                        g_voc_index_graph = create_graph_settings("voc_index_chart", "VOC Index", "", "green", CHART_HEIGHT);
                        draw_graph2(voc_index_readings, g_voc_index_graph);
                    }
                    else {
                        g_voc_index_graph.update_func(voc_index_readings);
                    }
                }
            }
        });
    }

    /// @function get_patio_monitor_readings
    function get_patio_monitor_readings(start_ts) {
        let api_url = "${root_url}/api/1.0/patio?start_ts=" + start_ts

        send_get_request_async(api_url, function (response_code, response_text) {
            if (response_code == 200) {
                const records = JSON.parse(response_text);

                var temp_readings = [];
                var humidity_readings = [];
                var wind_speed = [];
                var moisture_sensor_1_readings = [];
                var moisture_sensor_2_readings = [];

                for (let record of records) {
                    let ts = record['ts'];

                    temp_readings.push( { x: ts, y: record['temperature'] });
                    humidity_readings.push( { x: ts, y: record['humidity'] });
                    wind_speed.push( { x: ts, y: record['wind speed ms'] });
                    moisture_sensor_1_readings.push( { x: ts, y: record['moisture_sensor_1'] });
                    moisture_sensor_2_readings.push( { x: ts, y: record['moisture_sensor_2'] });
                }

                if (temp_readings.length > 0) {
                    if (g_patio_temp_graph == null) {
                        g_patio_temp_graph = create_graph_settings("temp_chart", "Patio Temperature", "C", "red", 250);
                        draw_graph2([], g_patio_temp_graph);
                    }
                    else {
                        g_patio_temp_graph.update_func(temp_readings);
                    }
                }
                if (humidity_readings.length > 0) {
                    if (g_patio_humidity_graph == null) {
                        g_patio_humidity_graph = create_graph_settings("humidity_chart", "Patio Humidity", "%", "blue", 250);
                        draw_graph2(humidity_readings, g_patio_humidity_graph);
                    }
                    else {
                        g_patio_humidity_graph.update_func(humidity_readings);
                    }
                }
                if (wind_speed.length > 0) {
                    if (g_patio_wind_speed_graph == null) {
                        g_patio_wind_speed_graph = create_graph_settings("wind_speed_chart", "Wind Speed (ms)", "m/s", "orange", 250);
                        draw_graph2(wind_speed, g_patio_wind_speed_graph);
                    }
                    else {
                        g_patio_wind_speed_graph.update_func(wind_speed);
                    }
                }
                if (moisture_sensor_1_readings.length > 0) {
                    if (g_patio_moisture1_graph == null) {
                        g_patio_moisture1_graph = create_graph_settings("moisture_sensor_1_chart", "Moisture Sensor #1", "%", "green", 250);
                        draw_graph2(moisture_sensor_1_readings, g_patio_moisture1_graph);
                    }
                    else {
                        g_patio_moisture1_graph.update_func(moisture_sensor_1_readings);
                    }
                }
                if (moisture_sensor_2_readings.length > 0) {
                    if (g_patio_moisture2_graph == null) {
                        g_patio_moisture2_graph = create_graph_settings("moisture_sensor_2_chart", "Moisture Sensor #2", "%", "green", 250);
                        draw_graph2(moisture_sensor_2_readings, g_patio_moisture2_graph);
                    }
                    else {
                        g_patio_moisture2_graph.update_func(moisture_sensor_2_readings);
                    }
                }
            }
        });
    }

    /// @function get_ac_readings
    function get_ac_readings(start_ts) {
        let api_url = "${root_url}/api/1.0/ac?start_ts=" + start_ts

        send_get_request_async(api_url, function (response_code, response_text) {
            if (response_code == 200) {
                const CHART_HEIGHT = 250;
                const records = JSON.parse(response_text);

                var ac_outlet_temp_readings = [];

                for (let record of records) {
                    let ts = record['ts'];
                    if (record['ac_outlet_temp'] != null)
                        ac_outlet_temp_readings.push( { x: ts, y: record['ac_outlet_temp'] });
                }

                if (ac_outlet_temp_readings.length > 0) {
                    if (g_ac_outlet_temp_graph == null) {
                        g_ac_outlet_temp_graph = create_graph_settings("ac_outlet_temp", "AC Outlet Temp", "", "red", CHART_HEIGHT);
                        draw_graph2(ac_outlet_temp_readings, g_ac_outlet_temp_graph);
                    }
                    else {
                        g_ac_outlet_temp_graph.update_func(ac_outlet_temp_readings);
                    }
                }
            }
        });
    }

    /// @function get_website_status
    function get_website_status(start_ts) {
        let api_url = "${root_url}/api/1.0/website_status?start_ts=" + start_ts

        send_get_request_async(api_url, function (response_code, response_text) {
            if (response_code == 200) {
                const records = JSON.parse(response_text);
                var graphs = {};

                records.forEach(record => {
                    let ts = record.ts;

                    for (const [key, value] of Object.entries(record)) {
                        if (key != 'ts') {
                            if (is_numeric(value.load_time_secs)) {
                                let new_item = {'x': ts, 'y': value.load_time_secs};

                                if (key in graphs) {
                                    graphs[key].push(new_item);
                                }
                                else {
                                    graphs[key]= [new_item];
                                }
                            }
                        }
                    }
                });

                for (const [key, value] of Object.entries(graphs)) {
                    if (key in g_website_status_graphs) {
                        graph_settings = g_website_status_graphs[key];
                        graph_settings.update_func(value);
                    }
                    else {
                        graph_settings = create_graph_settings(key, key, "Load Time (s)", "gray", 250);
                        g_website_status_graphs[key] = graph_settings;
                        draw_graph2(value, graph_settings);
                    }
                };
            }
        });
    }

    /// @function get_keg_readings
    function get_keg_readings(start_ts) {
        let api_url = "${root_url}/api/1.0/scale_calibration?name=keg";

        send_get_request_async(api_url, function (response_code, response_text) {
            if (response_code == 200) {
                const scale_calibration = JSON.parse(response_text);

                let api_url = "${root_url}/api/1.0/keg?start_ts=" + start_ts

                send_get_request_async(api_url, function (response_code, response_text) {
                    if (response_code == 200) {
                        const records = JSON.parse(response_text);

                        if (records.length > 0) {
                            let last_record = records[-1];
                            //g_keg_level.setPercentage(50);
                        }
                    }
                });
            }
        });
    }

    /// @function get_readings
    function get_readings() {
        var ts = Math.floor(g_readings_start_time.getTime() / 1000.0);

        get_indoor_air_quality_readings(ts);
        get_patio_monitor_readings(ts);
        get_keg_readings(ts);
        get_ac_readings(ts);
        get_website_status(ts);

        // Set the timer so we can get another refresh.
        g_readings_start_time = new Date();
        setTimeout(get_readings, 1000 * 60 * 5);
    }

    /// @function draw_gauges
    function draw_gauges() {
        g_co2_gauge = draw_co2_gauge("indoor-co2-gauge");
        g_co2_gauge.set(0);
        g_indoor_temp_gauge = draw_temperature_gauge("indoor-temp-gauge");
        g_indoor_temp_gauge.set(0);
        g_keg_level = draw_fluid_graph("keg-level");
        g_keg_level.setPercentage(50);
    }

    /// @function maybe_notify
    function maybe_notify(msg) {
        if (!("Notification" in window)) {
            return;
        }

        if (Notification.permission === "granted") {
            new Notification("ðŸ¡ Home Dashboard", { body: msg,
                tag: "temp-high", // helps collapse duplicates in some browsers
                renotify: true
            });
        }
    }

    /// @function request_notifications
    function request_notifications() {
        document.getElementById("enable_notifications").addEventListener("click", async () => {
            const perm = await Notification.requestPermission();
            alert("Notification permission: " + perm);
        });
    }

    draw_gauges();
    get_readings();
    request_notifications();

</script>

</body>

</html>
